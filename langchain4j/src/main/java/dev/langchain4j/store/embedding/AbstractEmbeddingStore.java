package dev.langchain4j.store.embedding;

import dev.langchain4j.data.embedding.Embedding;

import java.lang.reflect.InvocationTargetException;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * This parent class would implement the boilerplate code to invoke the concrete implementation.
 */
public abstract class AbstractEmbeddingStore<T> implements EmbeddingStore<T> {

    /** Concrete Implementation if class is available. */
    protected String implementationClassName;

    /**
     * Concrete Implementation (delegate Pattern).
     */
    protected EmbeddingStore<T> delegateImplementation;

    /**
     * Initialize the concrete implementation.
     */
    protected abstract EmbeddingStore<T> loadImplementation()
    throws ClassNotFoundException, NoSuchMethodException, InstantiationException,
           IllegalAccessException, InvocationTargetException;

    /**
     * Getter for the concrete implementation with an initialization.
     *
     * @return
     *      delegate implementation
     */
    protected EmbeddingStore<T> getDelegateImplementation() {
        if (delegateImplementation == null) {
            try {
                this.delegateImplementation = loadImplementation();
            } catch(ClassNotFoundException cnf) {
                throw new RuntimeException(
                        "Class '" + implementationClassName + "' not found, please checks your dependencies.", cnf);
            } catch(NoSuchMethodException e) {
                throw new IllegalArgumentException(
                        "Class '" + implementationClassName + "' does not have constructor with expected parameters", e);
            } catch (InvocationTargetException | InstantiationException | IllegalAccessException e) {
                throw new IllegalArgumentException(
                        "Constructor of class '" + implementationClassName + "' cannot be invoked check visibility or code.", e);
            } catch(Exception e) {
                throw new RuntimeException("Unexpected error while loading implementation", e);
            }
        }
        return delegateImplementation;
    }

    /**
     * Add embedding (vector only) to the store. The id is generated by the store.
     *
     * @param embedding
     *      The embedding (vector) to be added to the store.
     * @return
     *      unique id of the embedding
     */
    @Override
    public String add(Embedding embedding) {
        return getDelegateImplementation().add(embedding);
    }

    /**
     * Add embedding (vector only) to the store enforcing its identifier.
     *
     * @param embeddingId
     *      unique identifier of the embedding
     * @param embedding
     *      The embedding (vector) to be added to the store.
     */
    @Override
    public void add(String embeddingId, Embedding embedding) {
        Objects.requireNonNull(embeddingId, "embeddingId (param[0]) must not be null");
        Objects.requireNonNull(embedding, "embedding (param[1]) must not be null");
        getDelegateImplementation().add(embeddingId, embedding);
    }

    /**
     * Add embedding to the store with text and metadata. The id is generated by the store.
     *
     * @param embedding
     *      The embedding (vector) to be added to the store.
     * @param textSegment
     *      Text and metadata
     * @return
     *      unique id of the embedding
     */
    @Override
    public String add(Embedding embedding, T textSegment) {
        Objects.requireNonNull(embedding, "embedding (param[0]) must not be null");
        return getDelegateImplementation().add(embedding, textSegment);
    }

    /**
     * Add a list of embeddings to the store.
     *
     * @param embeddings
     *      list of embeddings
     * @return
     *      list of ids
     */
    @Override
    public List<String> addAll(List<Embedding> embeddings) {
        Objects.requireNonNull(embeddings, "embeddings must not be null");
        return embeddings.stream().map(this::add).collect(Collectors.toList());
    }

    /**
     * Add a list of embeddings to the store.
     *
     * @param embeddings
     *      list of embeddings
     * @param textSegments
     *      list of text segments
     * @return
     *      list of ids
     */
    @Override
    public List<String> addAll(List<Embedding> embeddings, List<T> textSegments) {
        Objects.requireNonNull(embeddings, "embeddings (param[0] must not be null");
        Objects.requireNonNull(textSegments, "textSegments (param[1] must not be null");
        if (embeddings.size() != textSegments.size()) {
            throw new IllegalArgumentException("embeddings and textSegment lists must have the same size");
        }
        return getDelegateImplementation().addAll(embeddings, textSegments);
    }

    /**
     * Search for relevant embeddings.
     *
     * @param referenceEmbedding
     *      The embedding used as a reference. Returned embeddings should be relevant (closest) to this one.
     * @param maxResults
     *      The maximum number of embeddings to be returned.
     * @return
     *      List of relevant embeddings.
     */
    @Override
    public List<EmbeddingMatch<T>> findRelevant(Embedding referenceEmbedding, int maxResults) {
        return getDelegateImplementation().findRelevant(referenceEmbedding, maxResults);
    }

    /**
     * Search for relevant embeddings.
     *
     * @param referenceEmbedding
     *      The embedding used as a reference. Returned embeddings should be relevant (closest) to this one.
     * @param maxResults
     *      The maximum number of embeddings to be returned.
     * @param minScore
     *     The minimum similarity score of the returned embeddings.
     * @return
     *      List of relevant embeddings.
     */
    @Override
    public List<EmbeddingMatch<T>> findRelevant(Embedding referenceEmbedding, int maxResults, double minScore) {
        return getDelegateImplementation().findRelevant(referenceEmbedding, maxResults, minScore);
    }

}
